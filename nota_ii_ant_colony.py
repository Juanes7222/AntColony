# -*- coding: utf-8 -*-
"""Nota II - Ant colony.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-k5u54cZyQ2fE8eS6zFH7zvFJgaj1ZZJ
"""


from bs4 import BeautifulSoup
from functools import singledispatch
from typing import Any
import requests
import os
import gzip
import shutil
import tsplib95
import re
import numpy as np
import matplotlib.pyplot as plt
import time
np.random.seed(0)

# URL donde están las soluciones óptimas (ajústala si es diferente)
SOLUCIONES_URL = "http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/STSP.html"

def get_optimal_solutions():
    response = requests.get(SOLUCIONES_URL)
    solutions = {}

    if response.status_code == 200:
        soup = BeautifulSoup(response.text, 'html.parser')
        for linea in soup.find_all('li'):
            text = linea.text.strip()
            match_ = re.match(r"\s*(?P<name>\w+)\s*:\s*(?P<value>\d+)\s*", text)
            if match_:
                solutions[match_.group('name')] = int(match_.group('value'))
    return solutions

# Obtener soluciones óptimas
optimal_solutions = get_optimal_solutions()
print(optimal_solutions)
# for nombre, valor in soluciones.items():
#     print(f"Problema {nombre} tiene solución óptima {valor}")

# URL de la página de TSPLIB95
TSPLIB_PAGE_URL = "http://comopt.ifi.uni-heidelberg.de/software/TSPLIB95/tsp/"

# Función para obtener la lista de archivos .tsp.gz disponibles
def get_problems_list():
    response = requests.get(TSPLIB_PAGE_URL)
    if response.status_code == 200:
        soup = BeautifulSoup(response.text, 'html.parser')
        links = soup.find_all('a', href=True)
        tsp_files = [link['href'] for link in links if link['href'].endswith('.tsp.gz')]
        opt_files = [link['href'] for link in links if link['href'].endswith('.opt.tour.gz')]
        return tsp_files, opt_files
    else:
        print("Error al obtener la lista de archivos TSPLIB95")
    return []

# Seleccionar aleatoriamente n problemas
def problem_select(list_, cant=1):
    return np.random.choice(list_, min(cant, len(list_)), replace=False)

def reduce_problems(problems: list, solutions: list):
    sol = list(map(lambda x: re.search(r"\w+.\.*", x).group(0).replace(".", ""), solutions))
    selected_problems = list(map(lambda x: x if re.search(r"\w+.\.*", x).group(0).replace(".", "") in sol else None, problems))
    selected_problems = list(filter(lambda x: x is not None, selected_problems))
    return selected_problems

# Descargar un problema
def download_problem(file_name):
    if (os.path.exists(file_name)):
        print(f"El archivo {file_name} ya existe.")
        return file_name
    url = TSPLIB_PAGE_URL + file_name
    response = requests.get(url, stream=True)
    if response.status_code == 200:
        with open(file_name, "wb") as file:
            shutil.copyfileobj(response.raw, file)
        print(f"Descargado: {file_name}")
        return file_name
    else:
        print(f"Error al descargar {file_name}")
        return None

# Descomprimir archivo .gz
def unzip_file(filename):
    if not filename:
        return None
    if filename.endswith('.gz'):
        if os.path.exists(filename[:-3]):
            print(f"El archivo {filename[:-3]} ya existe.")
            return filename[:-3]
        name = filename[:-3]  # Quitar .gz
        with gzip.open(filename, 'rb') as f_in:
            with open(name, 'wb') as f_out:
                shutil.copyfileobj(f_in, f_out)
        # os.remove(nombre_archivo)  # Borrar archivo comprimido
        print(f"Descomprimido: {name}")
        return name
    return filename

@singledispatch
def get_problem_name(tsp: tsplib95.models.StandardProblem):
    return tsp.name.split(".")[0]

@get_problem_name.register
def _(tsp: str):
    return os.path.basename(tsp).split(".")[0]

# Cargar problema con tsplib95
@singledispatch
def load_problem(filename: None, name: str):
    global optimal_solutions
    return optimal_solutions.get(name, None)

@load_problem.register
def _(filename: str, name: None):
    return tsplib95.load(filename)

def reduce_list(tsp_list: list, size: tuple):
    numbers = map(lambda x: re.search(r"\d+", x).group(0), tsp_list)
    return [x for x, number in zip(tsp_list, numbers) if int(number) >= size[0] and int(number) <= size[1]]

def search_solution(solutions, problem):
    name = get_problem_name(problem)
    for sol in solutions:
        if name == get_problem_name(sol):
            return sol

def prepare_problems(files: list, solutions: list):
    problems = {}
    tsp_solutions = {}
    selected_files = problem_select(files, 3)
    for i, file in enumerate(selected_files):
        file = download_problem(file)
        solution = search_solution(solutions, file)
        if solution:
            solution = download_problem(solution)
        if file:
            unziped_file = unzip_file(file)
            unziped_solution = unzip_file(solution)
            filename = get_problem_name(unziped_file)
            tsp = load_problem(unziped_file, filename)
            sol = load_problem(unziped_solution, filename)
            problems[filename] = tsp
            tsp_solutions[filename] = sol
            # print(sol)
    return problems, tsp_solutions

def get_coords(tsp):
    # print(tsp)
    # print(tsp.get_edges())
    # print(tsp.node_coords)
    return np.array(list(tsp.node_coords.values()))

ants_num = 50
alpha = 1.5
beta = 1
rho = 0.3
delta = rho
n = 100
best_path = []
best_distance = np.inf
max_iter = 1000

def distances(problem):
    if problem.edge_weight_type == 'EXPLICIT' and problem.edge_weight_format == 'FULL_MATRIX':
        return np.array(problem.edge_weights)
    n = problem.dimension
    d = np.zeros((n, n))
    # coords = problem.node_coords
    for i in range(n):
        for j in range(n):
            d[i, j] = problem.get_weight(i + 1, j + 1)

    return d

def rad_distance(cities: tsplib95.models.StandardProblem, optimal_tour: list | np.ndarray | int):
    if isinstance(optimal_tour, int):
        return optimal_tour
    optimal_distance = sum(
        cities.get_weight(optimal_tour[i], optimal_tour[i+1]) for i in range(len(optimal_tour) - 1)
    )
    return optimal_distance

def ant_colony(cities):
    np.random.seed(0)
    global max_iter
    global ants_num
    global alpha
    global beta
    global rho
    global delta
    d = distances(cities)
    n = len(d)
    tho = np.ones([n, n])
    # print(d)
    best_path = []
    best_distance = np.inf
    for iter in range(max_iter):
        paths = []
        path_lenghts = []
        for ant in range(ants_num):
            S = np.zeros(n)
            current_city = np.random.randint(n)
            S[current_city] = True
            path = [current_city]
            path_lenght = 0
            while not all(S):
                unvisited = np.where(S==False)[0]
                pij = np.zeros(len(unvisited))
                for j, unvisited_city in enumerate(unvisited):
                    pij[j] = (tho[current_city, unvisited_city]**alpha) * \
                    1/(d[current_city, unvisited_city]**beta)
                pij /= np.sum(pij)
                next_city = np.random.choice(unvisited, p=pij)
                path.append(next_city)
                path_lenght += d[current_city, next_city]
                current_city = next_city
                S[next_city] = True
            paths.append(path)
            path_lenghts.append(path_lenght)
            if path_lenght < best_distance:
                best_distance = path_lenght
                best_path = path

        tho *= (1-rho)
        for path, path_lenght in zip(paths, path_lenghts):
            for i in range(len(path)-1):
                tho[path[i], path[i+1]] += delta/path_lenght
            tho[path[-1], path[0]] += delta/path_lenght
    best_path.append(best_path[0])
    return best_path

def plot_solution(cities, solution, problem, distance, time_, gsp):
    for i in range(len(solution)-1):
        ini = cities[solution[i]]
        fin = cities[solution[i+1]]
        plt.arrow(ini[0], ini[1], fin[0]-ini[0], fin[1]-ini[1], head_width=0.1, head_length=0.3, fc='r', ec='r')
    # ini = cities[solution[-1]]
    # fin = cities[solution[0]]
    # plt.arrow(ini[0], ini[1], fin[0]-ini[0], fin[1]-ini[1], head_width=0.1, head_length=0.3, fc='r', ec='r')
    plt.title(f"Problem: {problem} Solution: {distance} Time: {time_:.4f}s GSP: {gsp:.4f}%")

problem_list, solutions = get_problems_list()
print(problem_list)
print(solutions)
# problem_list = reduce_problems(problem_list, solutions)

small_cities = reduce_list(problem_list, (10, 20))
small_cities_solutions = reduce_list(solutions, (10, 20))
print(small_cities)

median_cities = reduce_list(problem_list, (50, 100))
median_cities_solutions = reduce_list(solutions, (50, 100))

big_cities = reduce_list(problem_list, (100, 1000))
big_cities_solutions = reduce_list(solutions, (100, 1000))

small_cities, small_cities_solutions = prepare_problems(small_cities, small_cities_solutions)
# print(small_cities)
# print(small_cities_solutions)
# repare_selection(small_cities, small_cities_solutions)

median_cities, median_cities_solutions = prepare_problems(median_cities, median_cities_solutions)
# repare_selection(median_cities, median_cities_solutions)

big_cities, big_cities_solutions = prepare_problems(big_cities, big_cities_solutions)
# repare_selection(big_cities, big_cities_solutions)
print(small_cities)
print(small_cities_solutions)
print(median_cities)
print(median_cities_solutions)
print(big_cities)
print(big_cities_solutions)

def aply_aco(problem, index, solutions):
    cities = list(problem.values())[index]
    print(cities)
    start = time.time()
    best_path = ant_colony(cities)
    end = time.time()
    print(f"Solucion encontrada: {best_path}")
    return best_path, cities, end-start

best_path: Any
cities: Any
time_: Any

def init_instances(problem, index, solutions):
    global best_path
    global cities
    global time_
    best_path, cities, time_ = aply_aco(problem, index, solutions)
    sol = solutions.get(get_problem_name(cities))
    print(sol)
    distance, optimal_distance = check_solution(best_path, sol, cities)
    gsp = GSP(distance, optimal_distance)
    if hasattr(cities, 'node_coords'):
        coords = get_coords(cities)
        plot_solution(coords, best_path, cities.name, distance, time_, gsp)
    else:
        print("No se puede graficar")
    plt.savefig(f"{cities.name}.png", dpi=300, bbox_inches="tight")
    # plt.show()
    return best_path, cities

def GSP(aco_path_lenght, optimal_path_lenght):
    optimal_gsp = aco_path_lenght - optimal_path_lenght
    return (optimal_gsp/optimal_path_lenght)*100

def check_solution(best_path, solution, cities):
    if not isinstance(solution, int):
        optimal_tour = list(solution.tours[0])
        optimal_tour.append(optimal_tour[0])
    else:
        optimal_tour = solution
    optimal_distance = rad_distance(cities, optimal_tour)
    aco_tour = np.array(best_path) + 1
    distance = rad_distance(cities, aco_tour)
    print(f"Distancia del tour óptimo: {optimal_distance}")
    print(f"Distancia hallada: {distance}")
    return distance, optimal_distance

# best_path, cities = init_instances(median_cities, 0, median_cities_solutions)

for i in range(len(median_cities)):
    best_path, cities = init_instances(median_cities, i, median_cities_solutions)

for i in range(len(median_cities)):
    best_path, cities = init_instances(big_cities, i, big_cities_solutions)